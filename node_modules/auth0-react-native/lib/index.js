'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _regenerator = require('babel-runtime/regenerator');

var _regenerator2 = _interopRequireDefault(_regenerator);

var _asyncToGenerator2 = require('babel-runtime/helpers/asyncToGenerator');

var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

var _promise = require('babel-runtime/core-js/promise');

var _promise2 = _interopRequireDefault(_promise);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _typeof2 = require('babel-runtime/helpers/typeof');

var _typeof3 = _interopRequireDefault(_typeof2);

var _extends2 = require('babel-runtime/helpers/extends');

var _extends3 = _interopRequireDefault(_extends2);

var _stringify = require('babel-runtime/core-js/json/stringify');

var _stringify2 = _interopRequireDefault(_stringify);

var _abab = require('abab');

var _abab2 = _interopRequireDefault(_abab);

var _qs = require('qs');

var _qs2 = _interopRequireDefault(_qs);

var _jwtNodeDecoder = require('jwt-node-decoder');

var _LoginError = require('./LoginError');

var _LoginError2 = _interopRequireDefault(_LoginError);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* eslint valid-jsdoc: 0, no-undefined: 0, camelcase: 0 */
/* global fetch */


function assert(statement, message) {
  if (!statement) throw new Error(message);
}

function encodeBase64(str) {
  return _abab2.default.btoa(str).replace(/\+/g, '-').replace(/\//g, '_').replace(/\=+$/, '');
}

function isSuccessStatus(status) {
  return (/^(20\d|1223)$/.test(status)
  );
}

function log() {
  // console.log(...args);
}

function logError() {
  // console.error(...args);
}

function logAndReturn(res) {
  log('SUCCESS');
  log(res);
  // log(JSON.stringify(res, null, '  '));
  return res;
}

function logAndThrow(err) {
  logError('ERROR');
  log(err);
  // logError(JSON.stringify(err, null, '  '));
  throw err;
}

function processResponse(response) {
  log('RESPONSE');
  log(response.status);
  log(response.responseText);
  log(response);
  // logError(JSON.stringify(response, null, '  '));
  return response.json().then(logAndReturn, logAndThrow).then(function (json) {
    if (isSuccessStatus(response.status)) {
      return json;
    }
    response.responseText = (0, _stringify2.default)(json);
    throw response;
  });
}

function postJson(_ref) {
  var url = _ref.url;
  var data = _ref.data;
  var headers = _ref.headers;

  log('POST', url, (0, _stringify2.default)(data));
  return fetch(url, {
    method: 'POST',
    headers: (0, _extends3.default)({
      Accept: 'application/json',
      'Content-Type': 'application/json'
    }, headers),
    body: (0, _stringify2.default)(data)
  }).then(processResponse);
}

function sanitizeString(str) {
  return str ? str.trim() : '';
}

function handleRequestError(err) {
  var status = err.status;
  var responseText = typeof err.responseText === 'string' ? err.responseText : err;

  logError('ERROR', status, responseText, err);
  // log(JSON.stringify(err, null, '  '));

  if (!status) {
    status = 0;
    responseText = {
      code: 'connection_refused_timeout'
    };
  }

  throw new _LoginError2.default(status, responseText);
}

function throwLoginError(_ref2) {
  var status = _ref2.status;
  var responseText = _ref2.responseText;

  logError('LOGIN ERROR', status, responseText, typeof responseText === 'undefined' ? 'undefined' : (0, _typeof3.default)(responseText));
  throw new _LoginError2.default(status, responseText);
}

/**
 * Create an `Auth0` instance with `options`
 *
 * @constructor
 */

var Auth0 = function () {
  function Auth0(_ref3) {
    var _this = this;

    var clientID = _ref3.clientID;
    var domain = _ref3.domain;
    var callbackURL = _ref3.callbackURL;
    var callbackOnLocationHash = _ref3.callbackOnLocationHash;
    var sendSDKClientInfo = _ref3.sendSDKClientInfo;
    var device = _ref3.device;
    (0, _classCallCheck3.default)(this, Auth0);

    this.addProfile = function (auth) {
      log('addProfile', auth);
      return _this.getProfile(auth.id_token).then(function (profile) {
        return {
          auth: auth,
          profile: profile
        };
      });
    };

    assert(clientID, 'clientID is required!');
    assert(domain, 'domain is required!');

    this._clientID = clientID;
    this._domain = domain;
    this._callbackURL = callbackURL;
    this._shouldRedirect = Boolean(callbackURL);
    this._callbackOnLocationHash = callbackOnLocationHash;
    this._sendClientInfo = sendSDKClientInfo == null ? true : sendSDKClientInfo;
    this._device = device;
  }

  (0, _createClass3.default)(Auth0, [{
    key: 'getUrlForEndpoint',
    value: function getUrlForEndpoint(endpoint) {
      return 'https://' + this._domain + endpoint;
    }
  }, {
    key: '_getCallbackURL',
    value: function _getCallbackURL(_ref4) {
      var callbackURL = _ref4.callbackURL;

      return callbackURL === undefined ? this._callbackURL : callbackURL;
    }
  }, {
    key: '_getClientInfoString',
    value: function _getClientInfoString() {
      return encodeBase64((0, _stringify2.default)(Auth0.clientInfo));
    }
  }, {
    key: '_getClientInfoHeader',
    value: function _getClientInfoHeader() {
      return {
        'Auth0-Client': this._getClientInfoString()
      };
    }

    /**
     * Resolve response type as `token` or `code`
     *
     * @return {Object} options `scope` and `response_type` properties
     * @private
     */

  }, {
    key: '_getMode',
    value: function _getMode(options) {
      return {
        scope: 'openid',
        response_type: 'token'
      };
    }
  }, {
    key: '_configureOfflineMode',
    value: function _configureOfflineMode(options) {
      var scope = options.scope;
      var device = options.device;

      if (!device && scope && scope.indexOf('offline_access') >= 0) {
        options.device = this._device || 'ReactNative';
      }
    }

    /**
     * Get user information from API
     *
     * @param {Object} profile
     * @param {String} id_token
     * @private
     */

  }, {
    key: '_getUserInfo',
    value: function _getUserInfo(profile, id_token) {
      if (!profile || profile.user_id) {
        return _promise2.default.resolve(profile);
      }

      return postJson({
        url: this.getUrlForEndpoint('/tokeninfo'),
        data: { id_token: id_token }
      });
    }

    /**
     * Get profile data by `id_token`
     *
     * @param {String} id_token
     */

  }, {
    key: 'getProfile',
    value: function getProfile(id_token) {
      if (!id_token || typeof id_token !== 'string') {
        logError('id_token', id_token);
        return _promise2.default.reject(new Error('Invalid token'));
      }

      return this._getUserInfo((0, _jwtNodeDecoder.decodeToken)(id_token), id_token);
    }

    /**
     * Validate a user
     *
     * @param {Object} options
     */

  }, {
    key: 'validateUser',
    value: function validateUser(options) {
      if (!options.connection) {
        return _promise2.default.reject(new Error('connection parameter is mandatory'));
      }
      return fetch(this.getUrlForEndpoint('/public/api/users/validate_userpassword'), {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: (0, _stringify2.default)((0, _extends3.default)({
          client_id: this._clientID
        }, options, {
          username: sanitizeString(options.username || options.email)
        }))
      }).then(function (res) {
        return res.status === 200;
      }, function (error) {
        if (error.status === 404) return false;
        throw error;
      });
    }

    /**
     * Signup
     *
     * @param {Object} options Signup Options
     * @param {String} email New user email
     * @param {String} password New user password
     */

  }, {
    key: 'signup',
    value: function () {
      var ref = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee(options) {
        var query, response;
        return _regenerator2.default.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                query = (0, _extends3.default)({}, this._getMode(options), {
                  client_id: this._clientID,
                  tenant: this.tenant,
                  redirect_uri: this._getCallbackURL(options)
                }, options, {
                  // TODO Change this to a property named 'disableSSO' for consistency.
                  // By default, options.sso is true
                  sso: options.sso == null ? true : options.sso,
                  auto_login: options.auto_login == null ? true : options.auto_login,
                  username: sanitizeString(options.username),
                  email: sanitizeString(options.email || options.username)
                });


                this._configureOfflineMode(query);

                _context.next = 4;
                return postJson({
                  url: this.getUrlForEndpoint('/dbconnections/signup'),
                  data: query
                }).catch(throwLoginError);

              case 4:
                response = _context.sent;

                if (!query.auto_login) {
                  _context.next = 7;
                  break;
                }

                return _context.abrupt('return', this.login(options));

              case 7:
                return _context.abrupt('return', response);

              case 8:
              case 'end':
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function signup(_x) {
        return ref.apply(this, arguments);
      }

      return signup;
    }()

    /**
     * Change password
     *
     * @param {Object} options
     */

  }, {
    key: 'changePassword',
    value: function changePassword(options) {
      return postJson({
        url: this.getUrlForEndpoint('/dbconnections/change_password'),
        data: (0, _extends3.default)({
          tenant: this.tenant,
          client_id: this._clientID
        }, options, {
          username: sanitizeString(options.username),
          email: sanitizeString(options.email || options.username)
        })
      }).catch(throwLoginError);
    }

    /**
     * Builds parameter dictionary to be passed to /authorize based on dict key and values.
     *
     * @param {Object} query
     * @param {Array} blacklist
     * @private
     */

  }, {
    key: '_buildAuthorizationParameters',
    value: function _buildAuthorizationParameters(query, blacklist) {
      // Adds offline mode to the query
      this._configureOfflineMode(query);

      // Adds client SDK information (when enabled)
      if (this._sendClientInfo) {
        query.auth0Client = this._getClientInfoString();
      }

      // Elements to filter from query string
      (blacklist || ['popup', 'popupOptions']).forEach(function (key) {
        delete query[key];
      });

      if (Array.isArray(query.connection_scope)) {
        query.connection_scope = query.connection_scope.join(',');
      }

      return query;
    }

    /**
     * Builds query string to be passed to /authorize based on dict key and values.
     *
     * @param {Object} query
     * @param {Array} blacklist
     * @private
     */

  }, {
    key: '_buildAuthorizeQueryString',
    value: function _buildAuthorizeQueryString(query, blacklist) {
      return _qs2.default.stringify(this._buildAuthorizationParameters(query, blacklist));
    }
  }, {
    key: '_authorize',
    value: function _authorize(options) {
      var query = this._buildAuthorizeQueryString((0, _extends3.default)({}, this._getMode(options), {
        client_id: this._clientID,
        redirect_uri: this._getCallbackURL(options)
      }, options));

      return fetch(this.getUrlForEndpoint('/authorize?' + query)).then(processResponse);
    }

    /**
     * Login user
     *
     * @param {Object} options
     */

  }, {
    key: 'login',
    value: function login(options) {
      // TODO Change this to a property named 'disableSSO' for consistency.
      // By default, options.sso is true
      if (options.sso == null) options.sso = true;

      if (options.passcode !== undefined) {
        return this.loginWithPasscode(options);
      }

      if (options.username !== undefined || options.email !== undefined) {
        return this.loginWithUsernamePassword(options);
      }

      return this._authorize(options);
    }
  }, {
    key: 'signin',
    value: function signin(options) {
      return this.login(options);
    }
  }, {
    key: 'loginWithResourceOwner',


    /**
     * Login with Resource Owner (RO)
     *
     * @param {Object} options
     */
    value: function loginWithResourceOwner(options) {
      var query = (0, _extends3.default)({}, this._getMode(options), {
        client_id: this._clientID,
        grant_type: 'password'
      }, options, {
        username: sanitizeString(options.username || options.email)
      });

      this._configureOfflineMode(query);

      return postJson({
        url: this.getUrlForEndpoint('/oauth/ro'),
        data: query,
        headers: this._getClientInfoHeader()
      }).then(this.addProfile).catch(handleRequestError);
    }

    /**
     * Login with Social Access Token
     *
     * @param {Object} options
     */

  }, {
    key: 'loginWithSocialAccessToken',
    value: function loginWithSocialAccessToken(options) {
      return postJson({
        url: this.getUrlForEndpoint('/oauth/access_token'),
        data: this._buildAuthorizationParameters((0, _extends3.default)({
          scope: 'openid',
          client_id: this._clientID
        }, options)),
        headers: this._getClientInfoHeader()
      }).then(this.addProfile).catch(handleRequestError);
    }

    /**
     * Login with Username and Password
     *
     * @param {Object} options
     */

  }, {
    key: 'loginWithUsernamePassword',
    value: function loginWithUsernamePassword(options) {
      if (!options.sso) {
        return this.loginWithResourceOwner(options);
      }

      /*
        TODO
      if (options.sso) {
        return this.loginWithUsernamePasswordAndSSO(options);
      }
      */

      var query = (0, _extends3.default)({}, this._getMode(options), {
        client_id: this._clientID,
        tenant: this.tenant,
        redirect_uri: this._getCallbackURL(options)
      }, options, {
        username: sanitizeString(options.username || options.email)
      });

      this._configureOfflineMode(query);

      return postJson({
        url: this.getUrlForEndpoint('/usernamepassword/login'),
        data: query,
        headers: this._getClientInfoHeader()
      }).catch(handleRequestError);
    }
  }, {
    key: '_verify',
    value: function _verify(options) {
      return postJson({
        url: this.getUrlForEndpoint('/passwordless/verify'),
        data: options,
        headers: this._getClientInfoHeader()
      });
    }
  }, {
    key: '_verify_redirect',
    value: function _verify_redirect(options) {
      var query = this._buildAuthorizeQueryString((0, _extends3.default)({}, this._getMode(options), {
        client_id: this._clientID,
        redirect_uri: this._getCallbackURL(options)
      }, options));

      return this._redirect(this.getUrlForEndpoint('/passwordless/verify_redirect?' + query));
    }

    /**
     * Login with phone number and passcode
     *
     * @param {Object} options
     */

  }, {
    key: 'loginWithPasscode',
    value: function loginWithPasscode(options) {
      var _this2 = this;

      var _options = options;
      var email = _options.email;
      var phoneNumber = _options.phoneNumber;
      var passcode = _options.passcode;

      assert(email != null || phoneNumber != null, 'email or phoneNumber is required for authentication');

      assert(passcode != null, 'passcode is required for authentication');

      var useSMS = email == null;
      options.connection = useSMS ? 'sms' : 'email';

      if (!this._shouldRedirect) {
        options = (0, _extends3.default)({}, options, {
          username: useSMS ? phoneNumber : email,
          password: passcode,
          sso: false
        });

        delete options.email;
        delete options.phoneNumber;
        delete options.passcode;

        return this.loginWithResourceOwner(options);
      }

      var verifyOptions = {
        connection: options.connection
      };

      if (phoneNumber) {
        options.phone_number = phoneNumber;
        verifyOptions.phone_number = phoneNumber;
        delete options.phoneNumber;
      }

      if (email) {
        verifyOptions.email = email;
      }

      options.verification_code = passcode;
      verifyOptions.verification_code = passcode;
      delete options.passcode;

      return this._verify(verifyOptions).then(function () {
        return _this2._verify_redirect(options);
      });
    }

    /**
     * Trigger logout redirect with params from `query` object
     *
     * @example
     *
     *     auth0.logout();
     *     // redirects to -> 'https://yourapp.auth0.com/logout'
     *
     * @example
     *
     *     auth0.logout({returnTo: 'http://logout'});
     *     // redirects to -> 'https://yourapp.auth0.com/logout?returnTo=http://logout'
     *
     * @param {Object} query
     */

  }, {
    key: 'logout',
    value: function logout(query) {
      var url = this.getUrlForEndpoint('/logout');
      if (query) url += '?' + _qs2.default.stringify(query);
      return this._redirect(url);
    }

    /**
     * Get all configured connections for a client
     *
     * @example
     *
     *     auth0.getConnections(function (err, conns) {
     *       if (err) return console.log(err.message);
     *       expect(conns.length).to.be.above(0);
     *       expect(conns[0].name).to.eql('Apprenda.com');
     *       expect(conns[0].strategy).to.eql('adfs');
     *       expect(conns[0].status).to.eql(false);
     *       expect(conns[0].domain).to.eql('Apprenda.com');
     *       expect(conns[0].domain_aliases).to.eql(['Apprenda.com', 'foo.com', 'bar.com']);
     *     });
     *
     * @method getConnections
     */
    // XXX We may change the way this method works in the future to use client's s3 file.
    // TODO DOES NOT WORK
    /*
    getConnections() {
      return postJson({
        url: this.getUrlForEndpoint(`/public/api/${this._clientID}/connections`),
      });
    }
    */

    /**
     * Get delegation token for certain addon or certain other clientId
     *
     * @example
     *
     *     auth0.getDelegationToken({
     *       id_token:   '<user-id-token>',
     *       target:     '<app-client-id>'
     *       api_type: 'auth0'
     *     }).then((delegationResult) => {
     *       // Do stuff with delegation token
     *       expect(delegationResult.id_token).to.exist;
     *       expect(delegationResult.token_type).to.eql('Bearer');
     *       expect(delegationResult.expires_in).to.eql(36000);
     *     }, (err) => {
     *       console.log(err.message);
     *     });
     *
     * @example
     *
     *      // get a delegation token from a Firebase API App
     *     auth0.getDelegationToken({
     *       id_token:   '<user-id-token>',
     *       target:     '<app-client-id>'
     *       api_type: 'firebase'
     *     }).then((delegationResult) => {
     *       // Use your firebase token here
     *     });
     *
     * @param {Object} [options]
     * @param {String} [id_token]
     * @param {String} [target]
     * @param {String} [api_type]
     */

  }, {
    key: 'getDelegationToken',
    value: function getDelegationToken(options) {
      assert(options && (options.id_token || options.refresh_token), 'You must send either an id_token or a refresh_token to get a delegation token.');

      var query = (0, _extends3.default)({
        client_id: this._clientID,
        target: this._clientID,
        grant_type: 'urn:ietf:params:oauth:grant-type:jwt-bearer'
      }, options);

      return postJson({
        url: this.getUrlForEndpoint('/delegation'),
        data: query
      }).catch(function (err) {
        logError('ERROR', err);
        var error = void 0;
        try {
          error = JSON.parse(err.responseText);
        } catch (e) {
          var status = err.status;

          var details = void 0;
          if (status) {
            details = err;
          } else {
            status = 0;
            details = {
              code: 'connection_refused_timeout'
            };
          }
          throw new _LoginError2.default(status, details);
        }
        throw error;
      });
    }
  }, {
    key: 'renewIdToken',
    value: function renewIdToken(id_token) {
      return this.getDelegationToken({
        id_token: id_token,
        scope: 'passthrough',
        api_type: 'auth0'
      });
    }
  }, {
    key: 'refreshToken',
    value: function refreshToken(refresh_token) {
      return this.getDelegationToken({
        refresh_token: refresh_token,
        scope: 'passthrough',
        api_type: 'auth0'
      });
    }

    /**
     * Send email or SMS to do passwordless authentication
     *
     * @example
     *     // To send an email
     *     auth0.startPasswordless({email: 'foo@bar.com'}).then(
     *       (result) => {
     *         console.log(result);
     *       },
     *       (err) => {
     *         console.log(err.error_description);
     *       });
     *
     * @example
     *     // To send a SMS
     *     auth0.startPasswordless({phoneNumber: '+14251112222'}).then(
     *       (result) => {
     *         console.log(result);
     *       },
     *       (err) => {
     *         console.log(err.error_description);
     *       });
     *
     * @param {Object} options
     */

  }, {
    key: 'startPasswordless',
    value: function startPasswordless(options) {
      assert(options, 'An options object is required.');

      var email = options.email;
      var phoneNumber = options.phoneNumber;

      assert(email || phoneNumber, 'An `email` or a `phoneNumber` is required.');

      var data = { client_id: this._clientID };
      if (email) {
        data.email = email;
        data.connection = 'email';

        if (options.authParams) data.authParams = options.authParams;

        if (!options.send || options.send === 'link') {
          if (!data.authParams) data.authParams = {};

          data.authParams.redirect_uri = this._callbackURL;
          data.authParams.response_type = this._shouldRedirect && !this._callbackOnLocationHash ? 'code' : 'token';
        }

        if (options.send) data.send = options.send;
      } else {
        data.phone_number = phoneNumber;
        data.connection = 'sms';
      }

      return postJson({
        url: this.getUrlForEndpoint('/passwordless/start'),
        headers: this._getClientInfoHeader(),
        data: data
      });
    }
  }, {
    key: 'requestMagicLink',
    value: function requestMagicLink(attrs) {
      return this.startPasswordless(attrs);
    }
  }, {
    key: 'requestEmailCode',
    value: function requestEmailCode(attrs) {
      attrs.send = 'code';
      return this.startPasswordless(attrs);
    }
  }, {
    key: 'verifyEmailCode',
    value: function verifyEmailCode(attrs) {
      attrs.passcode = attrs.code;
      delete attrs.code;
      return this.login(attrs);
    }
  }, {
    key: 'requestSMSCode',
    value: function requestSMSCode(attrs) {
      return this.startPasswordless(attrs);
    }
  }, {
    key: 'verifySMSCode',
    value: function verifySMSCode(attrs) {
      attrs.passcode = attrs.code;
      delete attrs.code;
      return this.login(attrs);
    }
  }, {
    key: 'clientID',
    get: function get() {
      return this._clientID;
    }
  }, {
    key: 'domain',
    get: function get() {
      return this._domain;
    }
  }, {
    key: 'tenant',
    get: function get() {
      return this._domain.split('.')[0];
    }
  }]);
  return Auth0;
}();

Auth0.clientInfo = {
  name: 'auth0-react-native',
  version: '0.0.1'
};
Auth0.decodeToken = _jwtNodeDecoder.decodeToken;
Auth0.postJson = postJson;
Auth0.encodeBase64 = encodeBase64;
exports.default = Auth0;